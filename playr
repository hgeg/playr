#!/usr/bin/env python
import requests,time,re,os,sys,subprocess
import youtube_dl,thread,logging,libtorrent,HTMLParser
from flask import Flask,request,render_template
from flup.server.fcgi import WSGIServer
app = Flask(__name__)
yturl = r'(?:http(?:s|)://){0,1}(?:www.){0,1}youtu(?:\.be|be\.com)/(?:watch\?v=)([^\?&=]*)'
trurl = r'(http(?:s|)://[^"]*torrent[^"]*)'
queue,qlock = [],False


def download_media(url):
  cwd = os.getcwd()
  try:
    session = libtorrent.session()
    session.listen_on(6881, 6891)

    tfile = requests.get(url).content
    e = libtorrent.bdecode(tfile)
    info = libtorrent.torrent_info(e)
    info.rename_file(0,'media.tmp')

    h = session.add_torrent(info, cwd, storage_mode=libtorrent.storage_mode_t.storage_mode_compact)
    h.set_sequential_download(True)
    playing = False
    ctr = 10
  except Exception as e: return
  while not h.is_seed(): 
    s = h.status()
    if ctr==10: ctr = 0
    #TODO: pllay torrents after 10% loading.
    if not playing and s.progress>0.95:
      try:
        playing = True
        subprocess.call(["screen", "-S", "omx", "-X", "quit"])
        subprocess.Popen(['screen','-S','omx','omxplayer','-o','hdmi','media.tmp'])  
      except Exception as e: pass
    time.sleep(2)
    ctr+=1

def control(line):
  if "pause" == line: 
    subprocess.call(["screen", "-S", "omx", "-X", "stuff", 'p'])
  if "play" == line: 
    subprocess.call(["screen", "-S", "omx", "-X", "stuff", 'p'])
  if "stop" == line:
    subprocess.call(["screen", "-S", "omx", "-X", "stuff", 'q'])
  if "ff" == line:
    subprocess.call(["screen", "-S", "omx", "-X", "stuff", '\c[[C'])
  if "rw" == line:
    subprocess.call(["screen", "-S", "omx", "-X", "stuff", '\c[[D'])

@app.route("/playr/",methods = ['GET','POST'])
def play():
  if request.method == 'POST':
    ctrl = request.form['url']
    if ctrl in ('play','pause','stop','ff','rw'):
        control(ctrl)
        state = {'play':'playing','pause':'paused','stop':'http://','ff':'+30 secs','rw':'-30 secs'}
        return "control"+state[ctrl]
    elif 'queue' == ctrl[:5]:
      try:
        assert(not qlock)
        qlock = True
        queue.append(ctrl.split()[1])
        qlock = False
        return 'Queue:\n%s'%'\n'.join(queue)
      except:
        return 'Cannot access queue'
    elif ctrl == 'clear':
      try:
        assert(not qlock)
        qlock = True
        queue = []
        qlock = False
        return 'Queue cleared' 
      except:
        return 'Cannot access queue'
      
    try:
      url = ctrl
      url = url if 'http' in url else 'http://%s'%url
      if re.match(trurl,url):
        thread.start_new_thread(download_media,(url,))
        return 'torrent'
      try:
        ydl = youtube_dl.YoutubeDL({'outtmpl': '%(id)s%(ext)s'})
        ydl.add_default_info_extractors()
        result = ydl.extract_info(url,download=False)
        if 'entries' in result: video = result['entries'][0]
        else: video = result
        vurl = video['url']
      except:
        text = requests.get(url).text
        try:
          vurl = re.findall(r'file: "(.*)",',text)[0]
        except:
          vurl = ''
        url = re.findall(r'<iframe [^>]*src=(?:"|\')([^\'"]*(?:mail\.ru|vk)[^\'"]*)(?:"|\')[^>]*',text)[0]
        if 'mail.ru' in url:
          vdict = dict(re.findall(r'"{0,1}(hd|md|sd)"{0,1}:"([^"]*)"',requests.get(url).text))
          vurl = vdict['hd'] if 'hd' in vdict else vdict['md'] if 'md' in vdict else vdict['sd']
        elif 'vk' in url:
          url = HTMLParser.HTMLParser().unescape(url)
          vurl = re.findall(r'(http[^"(http)]*\.720.mp4)',requests.get(url).text)[0]
        elif 'daclip' in url:
          url = HTMLParser.HTMLParser().unescape(url)
          vurl = re.findall(r'(http[^"(http)]*\.mp4)',requests.get(url).text)[0]

      subprocess.call(["screen", "-S", "omx", "-X", "quit"])
      subprocess.Popen(['screen','-dmS','omx','omxplayer','-o','hdmi',vurl])  
      return 'url'
    except Exception as e: return 'error %s'%e.message
  else:
    t = render_template('playr.html')
    return t

if __name__ == "__main__":
    #subprocess.Popen(['screen','-S','cecmonitor','cec-client', '-m','RPI', '-f', 'ceclog'],stdout=subprocess.PIPE,stderr=subprocess.PIPE)
    #thread.start_new_thread(cec,('ceclog',))
    WSGIServer(app).run()
    #app.run(host='0.0.0.0',port=8774,debug=True)
